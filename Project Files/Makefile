#### Civilization 4 SDK Makefile 2.5 ####
####  Copyright 2015 Nightinggale    ####
#########################################
#### Civilization 4 SDK Makefile 2.0 ####
####  Copyright 2013 Nightinggale    ####
#########################################
#### Civilization 4 SDK Makefile 1.0 ####
####  Copyright 2010 Danny Daemonic  ####
#########################################

###############################################################
###############################################################
###                                                         ###
###   MODIFIED. NO longer part of the versioned makefiles   ###
###                                                         ###
###############################################################
###############################################################


## User setup
##
## Any setting here can be overwritten by assigning a new value to the variables in Makefile.settings
##  Makefile.settings is made automatically if it is missing whenever the project is build or cleaned
##
## Not touching the makefile itself can be beneficial if the makefile is committed to svn/git
## Makefile.settings can also accept CUSTOM_CFLAGS and CUSTOM_LDFLAGS if you want to ADD additional flags
##   the custom flags will not overwrite any flags the makefile sets itself
##   An example could be you want to define ENABLE_MY_DEBUG_OUTPUT in C+, then you write
##     CUSTOM_CFLAGS -DENABLE_MY_DEBUG_OUTPUT
##     in Makefile.settings and it will be defined for you without the risk of committing active debug output to other people
##
##     You can write whatever you want after -D and it will work like you write #DEFINE in C++
##


#### Paths ####

# Load paths from Makefile.auto
# It's autogenerated during source_list, which is called during the first call to the makefile
# Since the data from this file isn't needed until the second run, it will work even if reading this file is skipped.
# That's why the code here is allowed to skip reading a mandatory file if it's missing.

!IF [IF EXIST Makefile.auto EXIT 1] != 0
!include Makefile.auto
!ENDIF


#### Paths ####
#
# Note: $(PROGRAMFILES) converts to "C:\Program Files", "C:\Program Files (x86)" or whatever fits your system.
# run "nmake.exe /P" in cmd.exe to see what it is on your system
YOURMOD=..

## Civ install path
## Path to the directory where boost and python is stored
## Overwritten by enviroment variable CIV4_LIB_INSTALL_PATH
CIV4_PATH=..\..\..\CvGameCoreDLL

#### Tools ####
CC="$(TOOLKIT)\bin\cl.exe"
CPP="$(TOOLKIT)\bin\cl.exe"
LD="$(TOOLKIT)\bin\link.exe"
RC="$(PSDK)\bin\rc.exe"

#### BLACKLIST ####
## Uncomment to block CvTextScreen (accidentally included by Firaxis)
BLACKLIST=CvTextScreens

#### DEFINES ####
## copy the following lines into "Additional options" in NMAKE properties
## This will make VC++ aware of what is defined and what isn't, which affects the help popup and red lines
## Use Release_DEFINES for all targets except debug
## Assert adds /DFASSERT_ENABLE, which should be added to additional options too, if you care.
## However you will only be able to tell a difference if you do something with asserts other than FAssert() or FAssertMsg()

Debug_DEFINES=/DWIN32 /D_WINDOWS /DCVGAMECOREDLL_EXPORTS /D_DEBUG
Release_DEFINES=/DWIN32 /D_WINDOWS /DCVGAMECOREDLL_EXPORTS /DNDEBUG /DFINAL_RELEASE

#### You shouldn't need to modify anything beyond this point ####
#################################################################

TEMP_FILE_DIR = temp_files
CUSTOM_CFLAGS  =
CUSTOM_LDFLAGS =


# Perl binary setup
# Allows overwriting in Makefile.settings
PERL=perl

# set the heap size when creating the precompiled header file
# 100% = 75 MB. Max is 2000%
PRECOMPILE_MEMORY = /Zm150


!IF [IF NOT EXIST Makefile.settings EXIT 1] != 0
!IF [ECHO CUSTOM_CFLAGS = > Makefile.settings]
!ENDIF
!ENDIF
!include Makefile.settings

!IFDEF VERBOSE
HIDE_CHAR=
!ELSE
HIDE_CHAR=@
!ENDIF

PRECOMPILE_DEPENDENCIES =
PROJECT_CFLAGS =
PROJECT_LDFLAGS =
SOURCE_DIR =

!IF [IF NOT EXIST Makefile.project EXIT 1] != 0
!IF [ECHO SOURCE_DIR = .>> Makefile.project]
!ENDIF
!IF [ECHO PROJECT_CFLAGS = >> Makefile.project]
!ENDIF
!IF [ECHO PROJECT_LDFLAGS = >> Makefile.project]
!ENDIF
!IF [ECHO PRECOMPILE_DEPENDENCIES = >> Makefile.project]
!ENDIF
!ENDIF
!include Makefile.project

# TEMP_DIR_POSTFIX allows different settings for the same target, like Release with and without certain cflag (likely a define)
TEMP_TARGET_FILES = $(TEMP_FILE_DIR)\$(TARGET)$(TEMP_DIR_POSTFIX)

## Environmental path overwrite
!IFDEF CIV4_LIB_INSTALL_PATH
CIV4_PATH=$(CIV4_LIB_INSTALL_PATH)
!ENDIF

!IFDEF FASTDEP_FULL_PATH
FD=$(FASTDEP_FULL_PATH)
!ENDIF

# check if git is present and compiling from a git repository
!IF [IF EXIST $(GIT) EXIT 1] != 0
!IF [IF EXIST ..\.git EXIT 1] != 0
WITH_GIT=1
!ENDIF
!ENDIF

#### Target Files ####
Target_BIN=$(TEMP_TARGET_FILES)\CvGameCoreDLL.dll

!IF [IF NOT EXIST CvGameCoreDLL.rc EXIT 1] == 0
Target_RESOURCE=$(TEMP_TARGET_FILES)\CvGameCoreDLL.res
!ENDIF

Target_STATICLIB=$(TEMP_TARGET_FILES)\CvGameCoreDLL.lib

Target_PCH=$(TEMP_TARGET_FILES)\CvGameCoreDLL.pch

Target_PDB=$(TEMP_TARGET_FILES)\CvGameCoreDLL.pdb

Target_OTHER=$(TEMP_TARGET_FILES)\CvGameCoreDLL.exp

!IFDEF IGNORE_CUSTOM
CUSTOM_CFLAGS  =
CUSTOM_LDFLAGS =
!ENDIF

FILE_DEPENDS = $(TEMP_TARGET_FILES)\depends

#### CFLAGS ####
GLOBAL_CFLAGS=/GR /Z7 /Gy /W3 /EHsc /Gd /Gm- /Fd"$(Target_PDB)" $(CUSTOM_CFLAGS) $(PROJECT_CFLAGS)
Debug_CFLAGS=/MD /Od /RTC1 $(Debug_DEFINES) $(GLOBAL_CFLAGS)
Release_CFLAGS= /MD /O2 /Oy /Oi /G7 $(Release_DEFINES) $(GLOBAL_CFLAGS)

PRECOMPILE_CFLAGS1 = /Yu"
PRECOMPILE_CFLAGS2 = CvGameCoreDLL.h" /Fp"$(Target_PCH)"

#### LDFLAGS ####

# /DEBUG makes the linker make a pdb file (symbols), something we need for both debugging and profiling
GLOBAL_LDFLAGS=/DLL /NOLOGO /DEBUG /SUBSYSTEM:WINDOWS /LARGEADDRESSAWARE /TLBID:1 /PDB:"$(Target_PDB)" $(CUSTOM_LDFLAGS) $(PROJECT_LDFLAGS) /IGNORE:4089
Debug_LDFLAGS=/INCREMENTAL /IMPLIB:"$(Target_STATICLIB)" $(GLOBAL_LDFLAGS)
Release_LDFLAGS=/INCREMENTAL:NO /OPT:REF /OPT:ICF $(GLOBAL_LDFLAGS)

FAST_CFLAGS  = /GL
FAST_LDFLAGS = /LTCG

#### INCLUDES ####
GLOBAL_INCS=/I"$(TOOLKIT)/include" /I"$(PSDK)/Include" /I"$(PSDK)/Include/mfc"

#### boost and python ####

BOOST_LIB_PATH =
!IF [IF NOT EXIST "$(BOOST_LIB_PATH)Boost-1.32.0\libs\boost_python-vc71-mt-gd-1_32.lib" EXIT 1] != 0
BOOST_LIB_PATH = ../../Compiler/lib/
!IF [IF NOT EXIST "$(BOOST_LIB_PATH)Boost-1.32.0\libs\boost_python-vc71-mt-gd-1_32.lib" EXIT 1] != 0
BOOST_LIB_PATH = $(SOURCE_DIR)/
!IF [IF NOT EXIST "$(BOOST_LIB_PATH)Boost-1.32.0\libs\boost_python-vc71-mt-gd-1_32.lib" EXIT 1] != 0
BOOST_LIB_PATH=$(CIV4_PATH)/
!IF [IF NOT EXIST "$(BOOST_LIB_PATH)Boost-1.32.0\libs\boost_python-vc71-mt-gd-1_32.lib" EXIT 1] != 0
BOOST_LIB_PATH=$(CIV4_LIB_INSTALL_PATH)/
!IF [IF NOT EXIST "$(BOOST_LIB_PATH)Boost-1.32.0\libs\boost_python-vc71-mt-gd-1_32.lib" EXIT 1] != 0
!MESSAGE FATAL ERROR: Failed to locate boost and python
!ENDIF
!ENDIF
!ENDIF
!ENDIF
!ENDIF

#### tbb ####
TBB_PATH = tbb

PROJECT_INCS=/I"$(BOOST_LIB_PATH)Boost-1.32.0/include" /I"$(BOOST_LIB_PATH)Python24/include"
PROJECT_LIBS=/LIBPATH:"$(BOOST_LIB_PATH)Python24/libs" /LIBPATH:"$(BOOST_LIB_PATH)boost-1.32.0/libs/" boost_python-vc71-mt-1_32.lib /LIBPATH:"$(TBB_PATH)"

INCS = $(PROJECT_INCS) $(GLOBAL_INCS)

#### LIBS ####
GLOBAL_LIBS=/LIBPATH:"$(TOOLKIT)/lib" /LIBPATH:"$(PSDK)/Lib" winmm.lib user32.lib shell32.lib
LIBS = $(PROJECT_LIBS) $(GLOBAL_LIBS)


!IF "$(TARGET)" == "Debug"
CFLAGS  = $(Debug_CFLAGS)
LDFLAGS = $(Debug_LDFLAGS)
LIBS    = $(LIBS) msvcprt.lib tbb.lib tbbmalloc.lib
!ENDIF
!IF "$(TARGET)" == "Release"
CFLAGS  = $(Release_CFLAGS)
LDFLAGS = $(Release_LDFLAGS)
LIBS    = $(LIBS) tbb.lib tbbmalloc.lib
!ENDIF
!IF "$(TARGET)" == "FinalRelease"
CFLAGS  = $(Release_CFLAGS) $(FAST_CFLAGS)
LDFLAGS = $(Release_LDFLAGS) $(FAST_LDFLAGS) tbb.lib tbbmalloc.lib
!ENDIF
!IF "$(TARGET)" == "Assert"
CFLAGS  = $(Release_CFLAGS) /DFASSERT_ENABLE
LDFLAGS = $(Release_LDFLAGS)
LIBS    = $(LIBS) tbb.lib tbbmalloc.lib
!ENDIF
!IF "$(TARGET)" == "Profile"
CFLAGS  = $(Release_CFLAGS) $(FAST_CFLAGS) /DPROFILING_ENABLED
LDFLAGS = $(Release_LDFLAGS) $(FAST_LDFLAGS) tbb.lib tbbmalloc.lib
!ENDIF

!IFNDEF CFLAGS
!ERROR Target "$(TARGET)" not supported. Supported targets: Debug Release FinalRelease Assert Profile
!ENDIF

CFLAGS  = $(CFLAGS) $(CONFIG_CFLAGS)
LDFLAGS = $(LDFLAGS) $(CONFIG_DLFLAGS)

!IF EXIST ($(FILE_DEPENDS))
!INCLUDE $(FILE_DEPENDS)
!ENDIF

CFLAGS  = $(CFLAGS) $(CONFIG_CFLAGS)
LDFLAGS = $(LDFLAGS) $(CONFIG_DLFLAGS)

#### Targets ####
#################

.PHONY: all clean build precompile depends_setup source_list pre_test test test_DllExport BuildRelease header_building test_Python

all: Precompile build

dll: all

clean:
	@ECHO Deleting temp files
	@IF EXIST "$(TEMP_TARGET_FILES)" $(HIDE_CHAR)rmdir $(TEMP_TARGET_FILES) /s /q
	$(HIDE_CHAR)FOR %i IN ($(SOURCE_DIR)\autogenerated\*.h $(SOURCE_DIR)\autogenerated\*.hpp $(SOURCE_DIR)\autogenerated\*.cpp \
		"WeThePeople-*.zip" $(TEMP_FILE_DIR)"\python.timestamp") DO @IF EXIST "%i" DEL "%i"
	$(HIDE_CHAR)FOR %i IN (Test-Debug) DO @IF EXIST "%i" RMDIR "%i"  /s /q
	$(HIDE_CHAR)FOR %i IN (Assert Debug FinalRelease Release Profile) DO @IF EXIST "%i" RMDIR "%i"  /s /q || 1
	$(HIDE_CHAR)FOR %i IN (Assert Debug FinalRelease Release Profile) DO @IF EXIST "XML hardcoding-%i" RMDIR "XML hardcoding-%i"  /s /q || 1
	$(HIDE_CHAR)FOR %i IN (Assert Debug FinalRelease Release Profile) DO @IF EXIST "Single core-%i" RMDIR "Single core-%i"  /s /q || 1
	$(HIDE_CHAR)FOR %i IN (Assert Debug FinalRelease Release Profile) DO @IF EXIST "Multi core-%i" RMDIR "Multi core-%i"  /s /q || 1
	@IF EXIST "Build Release" $(HIDE_CHAR)rmdir "Build Release" /s /q

build: $(Target_BIN)
!IFDEF YOURMOD
	$(HIDE_CHAR)$(PERL) bin\copy.pl "$(Target_BIN)" "$(YOURMOD)\Assets\." verbose
	$(HIDE_CHAR)$(PERL) bin\copy.pl "$(Target_PDB)" "$(YOURMOD)\Assets\."
!IF "$(YOURMOD)" != ".."
	-xcopy "..\Assets\*" "$(YOURMOD)\Assets\*" /e /y /f /d
	-xcopy "..\PrivateMaps\*" "$(YOURMOD)\PrivateMaps\*" /e /y /f /d
!ENDIF
!ENDIF


precompile: Target_unfinished $(Target_PCH)

source_list: test_DllExport test_Python depends_setup
	
header_building:
	@ECHO Building headers
	$(HIDE_CHAR)$(PERL) bin\xml_enum_gen.pl
	$(HIDE_CHAR)$(PERL) bin\xml_enum_global_types.pl
	$(HIDE_CHAR)$(PERL) bin\InfoArray.pl
	$(HIDE_CHAR)$(PERL) bin\variable_setup.pl
	$(HIDE_CHAR)$(PERL) bin\Makefile_setup.pl "$(PROGRAMFILES)"

depends_setup: header_building
	@ECHO Setting up makefile depends
!IFDEF RELEASE_VERSION
	$(HIDE_CHAR)echo $(RELEASE_VERSION)| $(PERL) bin\git_version.pl
!ELSEIFDEF WITH_GIT
	$(HIDE_CHAR)$(GIT) rev-parse HEAD | $(PERL) bin\git_version.pl
!ELSE
	$(HIDE_CHAR)echo Unknown Version| $(PERL) bin\git_version.pl
!ENDIF
	$(HIDE_CHAR)$(PERL) bin\precompile.pl $(TEMP_TARGET_FILES) $(SOURCE_DIR) $(FILE_DEPENDS)

Target_unfinished:
	@ECHO.>$(TEMP_TARGET_FILES)\unfinished.@
	$(HIDE_CHAR)FOR /F "delims=@" %i IN ('dir /b $(TEMP_TARGET_FILES)\*.@') DO \
		@IF EXIST "$(TEMP_TARGET_FILES)\%i" DEL "$(TEMP_TARGET_FILES)\%i"

$(Target_BIN): $(OBJS) $(Target_RESOURCE)
	@ECHO.Linking DLL
	$(HIDE_CHAR)$(LD) /out:$(Target_BIN) $(LDFLAGS) $(LIBS) $(OBJS) $(Target_RESOURCE)

{$(SOURCE_DIR)\.}.c{$(TEMP_TARGET_FILES)\.}.obj:
    $(HIDE_CHAR)$(CPP) /nologo $(CFLAGS) $(INCS) /Fo$*.obj /c $<

$(Target_PCH) $(TEMP_TARGET_FILES)\_precompile.obj: $(PRECOMPILE_DEPENDENCIES)
	$(HIDE_CHAR)FOR %i IN ($(TEMP_TARGET_FILES)\*.obj) DO @IF EXIST "%i" DEL "%i"
    $(HIDE_CHAR)$(CPP) /nologo $(CFLAGS) $(PRECOMPILE_CFLAGS1)$(PRECOMPILE_CFLAGS2) $(PRECOMPILE_MEMORY) $(INCS) /YcCvGameCoreDLL.h /Fo"$(TEMP_TARGET_FILES)\_precompile.obj" /c $(SOURCE_DIR)\_precompile.cpp

.rc{$(TEMP_TARGET_FILES)}.res:
	$(AHIDE_CHART)$(RC) /Fo$@ $(INCS) $<

!IFDEF BLACKLIST
$(TEMP_TARGET_FILES)\$(BLACKLIST).obj: $(BLACKLIST).cpp
	@ECHO.>"$*.obj.@"
	@ECHO.>"$*-dummy.cpp"
	@$(CPP) /nologo $(Release_CFLAGS) $(Release_INCS) /Y- /Fo$@ /c "$*-dummy.cpp"
	@DEL "$*-dummy.cpp"
	@DEL "$*.obj.@"

!ENDIF

# Build a zip file based on the current head revision
# Includes custom code to inject the untracked dll file into the zip file
# NOTE: requires git 2.29 or newer. Git bundled with smartGIT at the time of writing this is 2.28
BuildRelease:
	@ECHO Building zip file
	$(HIDE_CHAR)cd ..
	$(HIDE_CHAR)$(GIT) archive --format=zip --prefix=Assets/ --add-file=Assets/CvGameCoreDLL.dll --prefix= -9 --output "Project Files"/WeThePeople-temp.zip head
	$(HIDE_CHAR)cd "Project Files"
	$(HIDE_CHAR)echo $(RELEASE_VERSION)| $(PERL) bin\git_version.pl
	@ECHO Generating checksums
	$(HIDE_CHAR)$(PERL) bin/checksums-zip.pl > checksums.txt

###
### test targets
###
# testing is done for automated testing. It's not intended to produce a working DLL file. In fact it won't even produce one at all

# this test is really fast (below 0.01 seconds) and is always executed in target source_list
test_DllExport:
	@ECHO Testing DllExport
	$(HIDE_CHAR)$(PERL) bin\DllExport.pl "$(SOURCE_DIR)"
	$(HIDE_CHAR)$(PERL) bin\xml_validation.pl
	$(HIDE_CHAR)$(PERL) bin\CPP_line_checker.pl

test_Python: header_building
	$(HIDE_CHAR)$(PERL) bin\python_enum_check.pl

# first step in the testing process
# each target mentioned here will run in a dedicated process
# this allows testing to run in parallel with the precompiled header generation (a single threaded task)
pre_test: precompile

test: $(OBJS) $(Target_RESOURCE)
	@ECHO Verification complete
